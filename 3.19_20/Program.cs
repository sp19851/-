using _3._19_20.Classes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _3._19_20
{
    //Виртуальный метод.
    class OverrideDemo
    {
        static void Main()
        {
            BaseClass baseOb = new BaseClass();
            DerivedClass dOb1 = new DerivedClass();
            Derived2Class dOb2 = new Derived2Class();
            BaseClass baseRef; // ссылка на базовый класс
            baseRef = baseOb;
            baseRef.Who();
            baseRef = dOb1;
            baseRef.Who();
            baseRef = dOb2;
            baseRef.Who();

            Console.ReadLine();
        }

        // В коде из приведенного выше примера создаются базовый класс Base и два
        //производных от него класса — Derived1 и Derived2.В классе Base объявляется
        //виртуальный метод Who(), который переопределяется в обоих производных классах.
        //Затем в методе Main() объявляются объекты типа Base, Derivedl и Derived2.
        //Кроме того, объявляется переменная baseRef ссылочного типа Base. Далее ссылка
        //на каждый тип объекта присваивается переменной baseRef и затем используется
        //для вызова метода Who(). Как следует из результата выполнения приведенного
        //выше кода, вариант выполняемого метода Who() определяется по типу объекта, к
        //которому происходит обращение по ссылке во время вызова этого метода, а не по типу класса переменной baseRef.
        //Но переопределять виртуальный метод совсем не обязательно.Ведь если в
        //производном классе не предоставляется собственный вариант виртуального метода,
        //то используется его вариант из базового класса.
        //При надлежащем применении базовый класс предоставляет все необходимые элементы,
        //которые могут использоваться в производном классе непосредственно.
        //А с помощью виртуальных методов в базовом классе определяются те методы,
        //которые могут быть самостоятельно реализованы в производном классе.
        //Таким образом, сочетая наследование с виртуальными методами, можно определить в базовом
        //классе общую форму методов, которые будут использоваться во
        //всех его производных классах.
    }
}
